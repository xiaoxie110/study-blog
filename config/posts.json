{
  "posts": [
    {
      "content": "[Illuminate/Cache/Repository.php][1]\r\n[Illuminate/Cache/CacheManager.php][2]\r\n#### 配置\r\n> Laravel 支持多种缓存系统, 并提供了统一的api接口，支持以下几种缓存模式，默认为file。默认的缓存配置文件在 config/cache.php\r\n```PHP\r\n 'stores' => [\r\n       //APC缓存，APC是PHP的一个扩展，可选PHP缓存。它提供了缓存和优化PHP的中间代码的框架。 APC的缓存分两部分:系统缓存和用户数据缓存 https://www.php.net/manual/zh/book.apc.php\r\n        'apc' => [\r\n            'driver' => 'apc',\r\n        ],\r\n        //数组缓存驱动（array）往往仅仅用于测试，好处是不会持久化，只会在一次PHP脚本执行的生命周期内有效\r\n        'array' => [\r\n            'driver' => 'array',\r\n            'serialize' => false,\r\n        ],\r\n        // 数据库缓存驱动（database）将缓存数据存储到数据库中，使用之前需要在数据库中新建一张表用于存放缓存项，该表表结构可定义如下\r\n        'database' => [\r\n            'driver' => 'database',\r\n            'table' => 'cache',\r\n            'connection' => null,\r\n        ],\r\n        // 文件缓存驱动（file）往往只用于本地开发测试，因为文件缓存将缓存存储到文件中，读取时从硬盘读取，性能自然不及基于内存的缓存系统如APC或Memcached以及Redis。\r\n        'file' => [\r\n            'driver' => 'file',\r\n            'path' => storage_path('framework/cache/data'),\r\n        ],\r\n        // （memcached）缓存驱动基于Memcached，是基于内存的分布式缓存系统；读写性能优异，特别是高并发时和文件缓存比有明显优势；支持集群，并且是自动管理负载均衡。\r\n        'memcached' => [\r\n            'driver' => 'memcached',\r\n            'persistent_id' => env('MEMCACHED_PERSISTENT_ID'),\r\n            'sasl' => [\r\n                env('MEMCACHED_USERNAME'),\r\n                env('MEMCACHED_PASSWORD'),\r\n            ],\r\n            'options' => [\r\n                // Memcached::OPT_CONNECT_TIMEOUT => 2000,\r\n            ],\r\n            'servers' => [\r\n                [\r\n                    'host' => env('MEMCACHED_HOST', '127.0.0.1'),\r\n                    'port' => env('MEMCACHED_PORT', 11211),\r\n                    'weight' => 100,\r\n                ],\r\n            ],\r\n        ],\r\n        //Redis 是一个开源的，高级键值对存储数据库。由于它包含 字符串，哈希，列表，集合，和 有序集合 这些数据类型\r\n        'redis' => [\r\n            'driver' => 'redis',\r\n            'connection' => 'cache',\r\n        ],\r\n        // 云数据库 Amazon DynamoDB 是一项快速灵活的 NoSQL云数据库服务,它是完全托管的数据库\r\n        'dynamodb' => [\r\n            'driver' => 'dynamodb',\r\n            'key' => env('AWS_ACCESS_KEY_ID'),\r\n            'secret' => env('AWS_SECRET_ACCESS_KEY'),\r\n            'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\r\n            'table' => env('DYNAMODB_CACHE_TABLE', 'cache'),\r\n            'endpoint' => env('DYNAMODB_ENDPOINT'),\r\n        ],\r\n```\r\n\r\n\r\n#### 常用方法\r\n##### has()\r\n> has($key) 判断缓存中是否存在该键对应的缓存，missing()相反\r\n```PHP\r\n>>> use Illuminate\\Support\\Facades\\Cache;\r\n>>> Cache::put('key',1);\r\n>>> Cache::has('key');\r\n=> true\r\n>>> Cache::has('key2');\r\n=> false\r\n```\r\n\r\n##### get()\r\n> get($key, $default = null) 获取缓存key对应的值，$default可以传默认值，也可以使用函数,\r\nmany(array $keys)，getMultiple($keys, $default = null)类似\r\n```PHP\r\n>>> Cache::get('key1');\r\n=> null\r\n>>> Cache::get('key1', 2);//默认值\r\n=> 2\r\n>>> Cache::get(['key','key1']);//可一次获取多个指定key\r\n=> [\r\n     \"key\" => 1,\r\n     \"key1\" => null,\r\n   ]\r\n>>> Cache::get('key1',function(){return 3;});\r\n=> 3\r\n```\r\n\r\n##### pull()\r\n> pull($key, $default = null) 取回緩存key對應的值並移除\r\n```PHP\r\n>>> Cache::pull('key')\r\n=> 1\r\n>>> Cache::get('key')\r\n=> null\r\n```\r\n\r\n##### put()&add()\r\n> put($key, $value, $ttl = null);add($key, $value, $ttl = null) 存儲緩存 $ttl未过期时间，不传的forever\r\n```PHP\r\n>>> Cache::put('key',[1,2,3,4],100)\r\n=> true\r\n```\r\n\r\n##### increment()&&decrement()\r\n> 增加/减少緩存的值\r\n```PHP\r\n>>> Cache::add('key', 1)\r\n=> true\r\n>>> Cache::increment('key')\r\n=> 2\r\n>>> Cache::increment('key', 3)\r\n=> 5\r\n>>> Cache::decrement('key', 3)\r\n=> 2\r\n```\r\n\r\n##### remember()\r\n> remember($key, $ttl, Closure $callback) 獲取指定key的緩存值，如果不存在，則存儲并返回\r\n```PHP\r\nCache::remember('key', $minutes, function(){ return 'value' });\r\nCache::rememberForever('key', function(){ return 'value' });\r\n```\r\n\r\n##### forget()\r\n\r\n#### cache源码解读\r\nLaravel 中常用 Cache Facade 来操作缓存, 对应的实际类是 Illuminate\\Cache\\CacheManager 缓存管理类(工厂).\r\n>Cache::xxx()\r\n\r\n我们通过 CacheManager 类获取持有不同存储驱动的 Illuminate\\Cache\\Repository 类\r\n>CacheManager::store($name = null)\r\n\r\nRepository 仓库类代理了实现存储驱动接口 Illuminate\\Contracts\\Cache\\Store 的类实例.\r\n\r\n```PHP\r\n//在配置文件 config\\app.php 中定义了 Cache 服务提供者\r\n'providers' => [\r\n        // ......\r\n        Illuminate\\Cache\\CacheServiceProvider::class,\r\n        // ......\r\n    ],\r\n    \r\n//Illuminate\\Cache\\CacheServiceProvider 文件\r\n    public function register()\r\n    {\r\n        $this->app->singleton('cache', function ($app) {\r\n            return new CacheManager($app);//实例化CacheManager\r\n        });\r\n        $this->app->singleton('cache.store', function ($app) {\r\n            return $app['cache']->driver();\r\n        });\r\n        $this->app->singleton('memcached.connector', function () {\r\n            return new MemcachedConnector;\r\n        });\r\n    }\r\n```\r\n##### CacheManager\r\n>CacheManager 实现了 Illuminate\\Contracts\\Cache\\Factory 接口, 实现了一个简单工厂, 传入存储驱动名, 返回对应的驱动实例.\r\n```PHP\r\n// Cache\\Factory 工厂接口\r\nnamespace Illuminate\\Contracts\\Cache;\r\ninterface Factory\r\n{\r\n    /**\r\n     * Get a cache store instance by name.\r\n     *\r\n     * @param  string|null  $name\r\n     * @return \\Illuminate\\Contracts\\Cache\\Repository\r\n     */\r\n    public function store($name = null);\r\n}\r\n\r\n//CacheManager实现的简单工厂接口方法\r\nuse Aws\\DynamoDb\\DynamoDbClient;\r\nuse Closure;\r\nuse Illuminate\\Contracts\\Cache\\Factory as FactoryContract;\r\nuse Illuminate\\Contracts\\Cache\\Store;\r\nuse Illuminate\\Contracts\\Events\\Dispatcher as DispatcherContract;\r\nuse Illuminate\\Support\\Arr;\r\nuse InvalidArgumentException;\r\n\r\n/**\r\n * @mixin \\Illuminate\\Contracts\\Cache\\Repository\r\n */\r\nclass CacheManager implements FactoryContract\r\n{\r\n    /**\r\n     * Get a cache store instance by name, wrapped in a repository.\r\n     * 实现接口方法\r\n     * @param  string|null  $name\r\n     * @return \\Illuminate\\Contracts\\Cache\\Repository\r\n     */\r\n    public function store($name = null)\r\n    {\r\n        $name = $name ?: $this->getDefaultDriver();\r\n\r\n        return $this->stores[$name] = $this->get($name);\r\n    }\r\n    ...\r\n    \r\n    /**\r\n     * Resolve the given store.\r\n     * 解析过程\r\n     * 自定义驱动: 查看是否有通过 CacheManager::extend(...)自定义的驱动\r\n     * Laravel提供的驱动: 查看是否存在 CacheManager::createXxxDriver(...)方法\r\n     * 这些方法都是实现了 Illuminate\\Contracts\\Cache\\Repository 接口 \r\n     *\r\n     * @param  string  $name\r\n     * @return \\Illuminate\\Contracts\\Cache\\Repository\r\n     *\r\n     * @throws \\InvalidArgumentException\r\n     */\r\n    protected function resolve($name)\r\n    {\r\n        $config = $this->getConfig($name);\r\n\r\n        if (is_null($config)) {\r\n            throw new InvalidArgumentException(\"Cache store [{$name}] is not defined.\");\r\n        }\r\n\r\n        if (isset($this->customCreators[$config['driver']])) {\r\n            return $this->callCustomCreator($config);\r\n        } else {\r\n            $driverMethod = 'create'.ucfirst($config['driver']).'Driver';\r\n\r\n            if (method_exists($this, $driverMethod)) {\r\n                return $this->{$driverMethod}($config);\r\n            } else {\r\n                throw new InvalidArgumentException(\"Driver [{$config['driver']}] is not supported.\");\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    /**\r\n     * Register a custom driver creator Closure.\r\n     * 自定义一个驱动程序，$driver对应 config/cache.php 配置文件中的 driver 选项。 第二个参数是返回 Illuminate\\Cache\\Repository 实例的闭包,相当于一个服务容器的实例\r\n     * @param  string  $driver\r\n     * @param  \\Closure  $callback\r\n     * @return $this\r\n     */\r\n    public function extend($driver, Closure $callback)\r\n    {\r\n        $this->customCreators[$driver] = $callback->bindTo($this, $this);\r\n        return $this;\r\n    }\r\n\r\n    /**\r\n     * Dynamically call the default driver instance.\r\n     * 魔术方法 以便快速调用默认缓存驱动\r\n     *\r\n     * @param  string  $method\r\n     * @param  array  $parameters\r\n     * @return mixed\r\n     */\r\n    public function __call($method, $parameters)\r\n    {\r\n        return $this->store()->$method(...$parameters);\r\n    }\r\n```\r\n##### Repository\r\n>Illuminate\\Contracts\\Cache\\Repository 接口，Repository 是一个符合 PSR-16: Common Interface for Caching Libraries 规范的缓存仓库类, 其在Laravel相应的实现类: Illuminate\\Cache\\Repository,其实现了代理模式, 具体的实现是交由 Illuminate\\Contracts\\Cache\\Store 来处理（具体的store实现）, Repository 主要作用是\r\n提供一些便捷操作 读取等操作\r\nEvent 事件触发, 包括缓存命中/未命中、写入/删除键值\r\n\r\n##### Store\r\n>Illuminate\\Contracts\\Cache 缓存驱动是实际处理缓存如何写入/读取/删除的类，具体的实现类有：\r\n\r\n    - ApcStore \r\n    - ArrayStore \r\n    - NullStore \r\n    - DatabaseStore \r\n    - FileStore \r\n    - MemcachedStore\r\n    - RedisStore \r\n    - DynamoDbStore\r\n```PHP\r\nnamespace Illuminate\\Contracts\\Cache;\r\ninterface Store\r\n{\r\n    public function get($key);\r\n    public function many(array $keys);\r\n    public function put($key, $value, $minutes);\r\n    public function putMany(array $values, $minutes);\r\n    public function increment($key, $value = 1);\r\n    public function decrement($key, $value = 1);\r\n    public function forever($key, $value);\r\n    public function forget($key);\r\n    public function flush();\r\n    public function getPrefix();\r\n}\r\n```\r\n\r\n#### 控制反转\r\n> cache缓存使用了依赖注入，不反转的例子 Cache类依赖Redis, 每次使用缓存的时候我们都要new Redis()\r\n```PHP\r\nclass Cache {\r\n    public function __construct()\r\n    {\r\n        $this->store = new Redis();\r\n    }\r\n}\r\n```\r\n> 反转使用容器, 由容器实例化对应的类，把控制权给了容器, 每个使用缓存的地方， 引入的都是容器， 使用make解析出 缓存对象\r\n```PHP\r\nclass Cache {\r\n    public function __construct(Container $container)\r\n    {\r\n        $this->$container = $container;\r\n\r\n        $this->store = $this->container->make('cache');\r\n    }\r\n}\r\n```\r\n> 类似这样，绑定一个redis对象，使用的时候直接make()解析即可\r\n```PHP\r\n$this->app->singleton('cache', function ($app) {\r\n    return new Redis($app);\r\n});\r\n```\r\n>如果不想用redis缓存了，不使用反转的时候，需要去每个使用缓存的类中修改，使用控制转只需要在绑定的时候修改即可，当然实际的应用中，我们也不必去修改绑定，我们可以类似的通过配置来实现快速切换，类似于工厂模式注入\r\n```PHP\r\n//CacheManager类中可以通过读取配置getConfig()\r\n$this->app->singleton('cache', function ($app) {\r\n    return new CacheManager($app);\r\n});\r\n//CacheManager直接解析为对应的缓存方法\r\nprotected function resolve($name)\r\n    {\r\n        $config = $this->getConfig($name);\r\n\r\n        if (is_null($config)) {\r\n            throw new InvalidArgumentException(\"Cache store [{$name}] is not defined.\");\r\n        }\r\n\r\n        if (isset($this->customCreators[$config['driver']])) {\r\n            return $this->callCustomCreator($config);\r\n        } else {\r\n            $driverMethod = 'create'.ucfirst($config['driver']).'Driver';\r\n\r\n            if (method_exists($this, $driverMethod)) {\r\n                return $this->{$driverMethod}($config);\r\n            } else {\r\n                throw new InvalidArgumentException(\"Driver [{$config['driver']}] is not supported.\");\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n  [1]: https://github.com/xiaoxie110/laravel/blob/master/vendor/laravel/framework/src/Illuminate/Cache/Repository.php\r\n  [2]: https://github.com/xiaoxie110/laravel/blob/master/vendor/laravel/framework/src/Illuminate/Cache/CacheManager.php",
      "data": {
        "title": "Laravel学习-cache缓存",
        "date": "2020-06-20 21:27:10",
        "tags": [
          "laravel",
          "cache"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "laravel-xue-xi-cache-huan-cun"
    },
    {
      "content": "\r\n> 集合（Collection）Illuminate\\Support\\Collection 类了提供一个便捷的操作数组的封装。[Collection.php源码解读][1]\r\n\r\n[TOC]\r\n\r\n### 创建一个新的集合\r\n \r\n```PHP\r\n//collect 辅助函数会为指定的数组返回一个新的 Illuminate\\Support\\Collection 实例\r\n//构造函数\r\npublic function __construct($items = [])\r\n{\r\n    //可以直接将多种类型转换为数组 Laravel Eloquent ORM 也以集合的形式返回数据\r\n    $this->items = $this->getArrayableItems($items);\r\n}\r\n// 创建一个新的集合\r\n$newCollection = collect([1, 2, 3, 4, 5]);\r\n```\r\n\r\n### 静态函数 times()\r\n```PHP\r\n静态 times 方法通过调用给定次数的回调函数来创建新集合：\r\n\r\npublic static function times($number, callable $callback = null)\r\n{\r\n    if ($number < 1) {\r\n        return new static;\r\n    }\r\n    if (is_null($callback)) {// 回调函数为空，直接返回range()\r\n        return new static(range(1, $number));\r\n    }\r\n    return (new static(range(1, $number)))->map($callback);//给定次数调用回调函数\r\n}\r\n// 基本用法\r\n> Illuminate\\Support\\Collection::times(10, function ($number) {\r\n    return $number * 9;\r\n})all();\r\n=> [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]\r\n\r\n// 回调函数为空，直接返回range()\r\n> Illuminate\\Support\\Collection::times(2)->all();\r\n=> [1,2,]\r\n```\r\n### 懶集合 LazyCollection\r\n>LazyCollection 类利用了PHP的生成器来在保持低内存使用率的同时使用非常大的数据集 关键字（yield）。\r\n```PHP\r\nuse App\\LogEntry;\r\nuse Illuminate\\Support\\LazyCollection;\r\n\r\nLazyCollection::make(function () {\r\n    $handle = fopen('log.txt', 'r');\r\n    while (($line = fgets($handle)) !== false) {\r\n        yield $line;\r\n    }\r\n})->chunk(4)->map(function ($lines) {\r\n    return LogEntry::fromLines($lines);\r\n})->each(function (LogEntry $logEntry) {\r\n    // Process the log entry...\r\n});\r\n```\r\n\r\n### 基本数据处理\r\n#### avg()\r\n> avg($callback = null) 集合平均值，支持回调函数\r\n```PHP\r\n// 一般用法\r\n>>> collect([1, 1, 2, 4])->avg();\r\n=> 2\r\n\r\n// 指定键\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->avg('foo')\r\n=> 20\r\n\r\n// 回调函数\r\n>>> collect([['foo' => 10], ['foo' => 20], ['foo' => 40]])->avg(function($val){return $val['foo']/10;});\r\n=> 2.3333333333333\r\n```\r\n\r\n#### median()\r\n> median($key = null) 集合中位数，可以指定键\r\n```PHP\r\n// 一般用法\r\n>>> collect([1, 1, 2, 4])->median();\r\n=> 1.5\r\n\r\n// 指定键中位数\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->median('foo');\r\n=> 15\r\n```\r\n\r\n#### mode()\r\n> mode($key = null) 集合众数 指定键的众数[一组数据中出现次数最多的数值，有可能是多个]\r\n```PHP\r\n// 一般用法\r\n>>> collect([1, 1, 2, 4])->mode();\r\n=> [1]\r\n\r\n// 指定键众数\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 20], ['foo' => 40]])->mode('foo');\r\n=> [10,20]\r\n```\r\n\r\n#### collapse()\r\n> 一个多个一维数组集合组装为单个一维数组集合\r\n```PHP\r\n// 多个一维数组的值 array_merege\r\n>>> collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]])->collapse()->all()\r\n=> [1,2,3,4,5,6,7,8,9]\r\n// 不适用多维数组\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 20], ['foo' => 40]])->collapse()->all()\r\n=> [\"foo\" => 40]\r\n>>>\r\n```\r\n\r\n#### contains()\r\n>contains($key, $operator = null, $value = null) 方法检查集合有否包含指定的元素\r\ncontains 方法用 “松散” 比较检查元素值，用 containsStrict 方法使用 “严格” 比较过滤。\r\n```PHP\r\n// 单个数值或者回調函數判断\r\n>>> collect([1,2,3,4])->contains(1)\r\n=> true\r\n>>> collect([['foo' => 10],['foo' => 20]])->contains(function($val){ return $val['foo'] > 20 ;});\r\n=> true\r\n\r\n// 数组，键值对\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->contains(['foo' => 10])\r\n=> true\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->contains('foo',10)\r\n=> true\r\n// 支持多種比較查詢 == <> > < !== 等等\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->contains('foo', '>', 10)\r\n=> true\r\n```\r\n\r\n#### crossJoin()\r\n> crossJoin(...$lists)  方法交叉连接指定数组或集合的值，返回所有可能排列的笛卡尔积\r\n\r\n```PHP\r\n// 数组循环迭代，每次每个集合中取一个 类似于 An1*M \r\n>>> collect([1,2])->crossJoin([3,4])->all()\r\n=> [\r\n     [1,3],\r\n     [1,4],\r\n     [2,3],\r\n     [2,4],\r\n   ]\r\n>>>\r\n\r\n```\r\n\r\n#### diff()\r\n>数组中array_diff()方法，本函数只检查了多维数组中的一维\r\n```PHP\r\n>>> collect([1,2])->diff([1,2,3,4])->all()\r\n=> []\r\n>>> collect([1,2,5])->diff([1,2,3,4])->all()\r\n=> [2 => 5]\r\n```\r\n#### diffUsing()\r\n#### diffAssoc()\r\n#### diffAssocUsing()\r\n#### diffKeys()\r\n#### diffKeysUsing()\r\n#### duplicates()\r\n>duplicates($callback = null, $strict = false) 从集合中检索并返回重复的值\r\n```PHP\r\n// 一般用法\r\n>>> collect(['a', 'b', 'a', 'c', 'b'])->duplicates()->all()\r\n=> [2 => \"a\", 4 => \"b\"]\r\n// 如果集合包含数组或对象，则可以需要检查重复值的属性的键\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->duplicates('foo')->all();\r\n=> [1 => 10]\r\n```\r\n#### duplicatesStrict()\r\n#### except()\r\n> except($keys) 方法返回集合中除了指定键之外的所有集合项：\r\n```PHP\r\n// 参数可传单个字段，也可以传枚举类型的数组\r\n>>> collect(['foo' => 10, 'foo2' => 10, 'foo' => 40])->except('foo')->all();\r\n=> [\"foo2\" => 10]\r\n>>> collect(['foo' => 10, 'foo2' => 10, 'foo3' => 40])->except(['foo','foo2'])->all();\r\n=> [\"foo3\" => 10]\r\n```\r\n\r\n#### filter()\r\n> 用给定的回调函数过滤集合，只保留那些通过指定条件测试的集合项;如果没有提供回调函数，集合中所有返回 false 的元素都会被移除\r\n```PHP\r\n// 指定回调函数，过滤集合\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->filter(function($val){ return $val['foo'] > 20;})->all();\r\n=> [\r\n     2 => [\r\n       \"foo\" => 40,\r\n     ],\r\n   ]\r\n// 没有回调函数，直接过滤false array_filter()\r\n>>> collect([1, 2, 3, null, false, '', 0, []])->filter()->all()\r\n=> [1, 2, 3]\r\n```\r\n\r\n#### first()\r\n> first(callable $callback = null, $default = null) 从集合中返回符合条件的第一个值，支持回调函数；可设置默认值$default\r\n```PHP\r\n>>> collect()->first();\r\n=> null\r\n>>> collect([1, 2, 3, 4])->first();\r\n=> 1\r\n>>> collect([1, 2, 3, 4])->first(function($val){ return $val > 30;});\r\n=> null\r\n>>> collect([1, 2, 3, 4])->first(function($val){ return $val > 3;});\r\n=> 4\r\n>>> collect([1, 2, 3, 4])->first(function($val){ return $val > 5;}, 5);\r\n=> 5\r\n```\r\n\r\n#### flatten()\r\n> flatten($depth = INF) flatten($depth = INF) 将多维集合转换为一维集合，其中 $depth 为转换深度\r\n```PHP\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->flatten()->all();\r\n=> [10,10,40]\r\n>>> collect([1=>'a', 2=>['b'=>['c' => 'd']]])->flatten(2)->all()\r\n=> [\"a\",\"d\",]\r\n```\r\n\r\n#### flip()\r\n#### forget()\r\n> forget($keys) 通过指定的键来移除集合中对应的内容\r\n```PHP\r\n>>> collect(['foo' => 10, 'foo2' => 10, 'foo3' => 40])->forget(['foo','foo2'])->all();\r\n=> [\"foo3\" => 40]\r\n```\r\n#### get()\r\n> get($key, $default = null) 方法返回指定键的集合项，如果该键在集合中不存在，则返回 null；可传递默认参数default，该默认参数可为回调函数\r\n```PHP\r\n>>> collect(['a' => 1])->get('a')\r\n=> 1\r\n>>> collect(['a' => 1])->get('b')\r\n=> null\r\n>>> collect(['a' => 1])->get('b', 11)\r\n=> 11\r\n>>> collect(['a' => 1])->get('b', function(){return 111;})\r\n=> 111\r\n>>>\r\n```\r\n\r\n#### groupBy()\r\n#### keyBy()\r\n> 方法以指定的键作为新集合的键。如果多个集合项具有相同的键，则只有最后一个集合项会显示在新集合中;支持对调函数 \r\n```PHP\r\n// 一般使用，直接传递某个键\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->keyBy('a')->all()\r\n=> [\r\n     1 => [\"a\" => 1,\"b\" => 2,],\r\n     3 => [\"a\" => 3,\"b\" => 4,],\r\n   ]\r\n// 回调函数返回的值会作为该集合的键   \r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->keyBy(function($item){return $item['a']+10;})->all()\r\n=> [\r\n     11 => [\"a\" => 1,\"b\" => 2,],\r\n     13 => [\"a\" => 3,\"b\" => 4,],\r\n   ]\r\n```\r\n\r\n#### has()\r\n> has($key) 判断集合中是否存在指定键,支持传入多个键 array_key_exists底层方法\r\n```PHP\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->has('a')\r\n=> true\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->has(['a','b'])\r\n=> true\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->has(['a','b','d'])\r\n=> false\r\n```\r\n\r\n#### implode\r\n> implode($value, $glue = null) 用于合并集合项\r\n```PHP\r\n// 集合中包含简单的字符串或数值\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->implode('*')\r\n=> \"1*2*3\"\r\n// 集合包含数组或对象\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->implode('a', '**')\r\n=> \"1**3\"\r\n```\r\n\r\n#### intersect()\r\n#### intersectByKeys()\r\n#### isEmpty()\r\n#### join()\r\n>join($glue, $finalGlue = '') 将集合中的值用字符串连接\r\n```PHP\r\n>>> collect(['a', 'b', 'c'])->join(', ');\r\n=> 'a, b, c'\r\n>>> collect(['a', 'b', 'c'])->join(', ', ', and ');\r\n=> 'a, b, and c'\r\n>>> collect(['a', 'b'])->join(', ', ' and ');\r\n=> 'a and b'\r\n>>> collect(['a'])->join(', ', ' and '); \r\n=> 'a'\r\n>>> collect([])->join(', ', ' and '); \r\n=> ''\r\n```\r\n\r\n#### keys()\r\n#### last()\r\n>last() 返回集合中通过指定条件测试的最后一个元素\r\n```PHP\r\n// 一般调用，直接返回最后有一个元素\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->last();\r\n=> 3\r\n// 回调函数，返回符合条件的最后一个元素\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->last(function($val){return $val<2;});\r\n=> 1\r\n```\r\n\r\n#### pluck()\r\n> pluck($value, $key = null) 方法可以获取集合中指定键对应的所有值\r\n```PHP\r\n// 指定键对应的所有值\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->pluck('a')->all();\r\n=> [1,3]\r\n// 指定生成集合的键\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->pluck('a', 'b')->all();\r\n=> [2 => 1, 4 => 3]\r\n// 如果存在重复的键，则最后一个匹配元素将被插入到弹出的集合中\r\n>>> collect([['a'=>1,'b'=>2],['a'=>3,'b'=>2]])->pluck('a', 'b')->all();\r\n=> [2 => 3]\r\n```\r\n\r\n#### map()\r\n> map(callable $callback) 遍历集合并将每一个值传入给定的回调函数, 生成被修改过集合项的新集合\r\n```PHP\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>2]])->map(function($item, $key){ return $item['a'] * 2;})->all();\r\n=> [2,6]\r\n```\r\n\r\n#### mapToDictionary()\r\n#### mapWithKeys() \r\n>遍历集合并将每个值传入给定的回调函数。将返回一个包含单个键 / 值对的关联数组\r\n```PHP\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->mapWithKeys(function($item){return [$item['a'] => $item['b']];})->all()\r\n=> [\r\n     1 => 2,\r\n     3 => 4,\r\n   ]\r\n```\r\n\r\n#### merge() \r\n>方法将合并指定的数组或集合到原集合，如果给定的集合项的字符串键与原集合中的字符串键相匹配，则指定集合项的值将覆盖原集合的值 array_merge\r\n```PHP\r\n// 一般使用\r\n>>> collect([ 'a'=>1,'b'=>2])->merge(['c' => 5])->all();\r\n=> [\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n     \"c\" => 5,\r\n   ]\r\n// 有覆盖\r\n>>> collect([ 'a'=>1,'b'=>2])->merge(['a' => 5])->all();\r\n=> [\r\n     \"a\" => 5,\r\n     \"b\" => 2,\r\n   ]\r\n```\r\n#### mergeRecursive()\r\n> 以递归的形式合并给定的数组或集合到原集合中 array_merge_recursive\r\n```PHP\r\n// 同一个键值的合并\r\n>>> collect(['a'=>1,'b'=>2])->mergeRecursive(['a' => 5])->all();\r\n=> [\"a\" => [1,5,\"b\" => 2]\r\n>>> collect([ 'a'=>['c'=>1],'b'=>2])->mergeRecursive(['a' => 5])->all();\r\n=> [\"a\" => [\"c\" => 1,0 => 5,],\"b\" => 2,]\r\n```\r\n\r\n#### combine()\r\n> 将一个集合的值作为键，与另一个数组或集合的值进行结合 array_combine\r\n```PHP\r\n// 一般使用\r\n>>> collect(['a', 'b'])->combine([1,2])->all()\r\n=> [\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n   ]\r\n// 只能传递相等数量的集合\r\n>>> collect(['a', 'b'])->combine([1,2,3])->all()\r\nPHP Warning:  array_combine(): Both parameters should have an equal number of elements in D:/dev/study/laravel/vendor/laravel/framework/src/Illuminate/Support/Collection.php on line 777\r\n=> [\r\n     false,\r\n   ]\r\n```\r\n\r\n#### union()\r\n> 方法将给定数组添加到集合中。如果给定的数组含有与原集合一样的键，则首选原始集合的值,这点和merge相反\r\n```PHP\r\n>>> collect(['a'=>1, 'b'=>2])->union(['a'=>3,'d'=>4])->all()\r\n=> [\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n     \"d\" => 4,\r\n   ]\r\n>>> collect(['a'=>1, 'b'=>2])->merge(['a'=>3,'d'=>4])->all()\r\n=> [\r\n     \"a\" => 3,\r\n     \"b\" => 2,\r\n     \"d\" => 4,\r\n   ]\r\n\r\n```\r\n\r\n#### nth()\r\n\r\n#### only()\r\n> 返回集合中所有指定键的集合项\r\n```PHP\r\n>>> collect(['a'=>1, 'b'=>2])->only('a')->all()\r\n=> [\r\n     \"a\" => 1,\r\n   ]\r\n```\r\n\r\n#### pop()\r\n#### prepend()\r\n> prepend($value, $key = null) 将指定的值添加的集合的开头\r\n```PHP\r\n// 添加指定值到集合的开头\r\n>>> collect(['a'=>1,'b'=>2])->prepend('c')->all()\r\n=> [\r\n     0 => \"c\",\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n   ]\r\n// 指定新增集合项的键   \r\n>>> collect(['a'=>1,'b'=>2])->prepend('c',1)->all()\r\n=> [\r\n     1 => \"c\",\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n   ]\r\n```\r\n#### push()\r\n> push($value) 添加一个值于集合末尾,只能插入一个值\r\n```PHP\r\n>>> collect(['a','b'])->push('c','d')->all()\r\n=> [\"a\", \"b\", \"c\"]\r\n>>> collect([1, 2, 3])->push(4, 5)->all();\r\n=> [1, 2, 3, 4]\r\n```\r\n#### concat()\r\n> 在集合的末端附加指定的数组或者集合\r\n```PHP\r\n>>> collect([1, 2, 3])->concat([4, 5])->all();\r\n=> [1, 2, 3, 4, 5]\r\n```\r\n\r\n#### pull()\r\n> pull($key, $default = null) 指定键对应的值从集合中移除并返回,default为默认值\r\n```PHP\r\n>>> collect(['a'=>1,'b'=>2])->pull('a',0)\r\n=> 1\r\n>>> collect(['a'=>1,'b'=>2])->pull('c',3)\r\n=> 3\r\n```\r\n\r\n#### put()\r\n> put($key, $value) 设定集合内指定键的值，如果不存在，则新增到末尾\r\n```PHP\r\n>>> collect(['a'=>1,'b'=>2])->put('c',3)->all()\r\n=> [\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n     \"c\" => 3,\r\n   ]\r\n>>> collect(['a'=>1,'b'=>2])->put('a',3)->all()\r\n=> [\r\n     \"a\" => 3,\r\n     \"b\" => 2,\r\n   ]\r\n```\r\n\r\n#### random\r\n> random($number = null) 集合中返回一个随机项,$number不能大于集合的数量，否则报错\r\n```PHP\r\n// 默认返回一个\r\n>>> collect(['a'=>1,'b'=>2])->random()\r\n=> 2\r\n>>> collect(['a'=>1,'b'=>2])->random(2)->all()\r\n=> [\r\n     1,\r\n     2,\r\n   ]\r\n// 大于集合数量，报错   \r\n>>> collect(['a'=>1,'b'=>2])->random(3)->all()\r\nInvalidArgumentException with message 'You requested 3 items, but there are only 2 items available.'\r\n```\r\n\r\n#### reduce\r\n> reduce(callable $callback, $initial = null) 将每次迭代的结果传递给下一次迭代，直到遍历完集合\r\n```PHP\r\n// 循环迭代 返回res\r\n>>> collect([1, 2, 3])->reduce(function($res,$val){ return $res+$val;});\r\n=> 6\r\n// res初始值\r\n>>> collect([1, 2, 3])->reduce(function($res,$val){ return $res+$val;},10);\r\n=> 16\r\n```\r\n\r\n#### replace\r\n> replace 方法类似于 merge，不仅可以覆盖匹配到的相同字符串键的集合项，而且也可以覆盖数字键的集合\r\n```PHP\r\n>>> collect(['a'=>1,'b'=>2])->replace(['b'=>10])->all();\r\n=> [\r\n     \"a\" => 1,\r\n     \"b\" => 10,\r\n   ]\r\n>>> collect([1, 2, 3])->replace([1=>10])->all();\r\n=> [1, 10, 3]\r\n```\r\n\r\n#### replaceRecursive()\r\n\r\n#### reverse()\r\n\r\n#### search()\r\n>search($value, $strict = false) 集合的搜寻方法，搜索给定的值,返回键值\r\n```PHP\r\n// 搜寻指定的值\r\n>>> collect(['a'=>1,'b'=>2])->search('a');\r\n=> false\r\n>>> collect(['a'=>1,'b'=>2])->search('1');\r\n=> \"a\"\r\n// 指定严格模式\r\n>>> collect(['a'=>1,'b'=>2])->search('1',true);\r\n=> false\r\n// 指定回调函数\r\n>>> collect(['a'=>1,'b'=>2])->search(function($item,$key){return $item > 1;});\r\n=> \"b\"\r\n```\r\n\r\n#### shift()\r\n#### shuffle()\r\n#### skip()\r\n#### slice()\r\n> slice($offset, $length = null) 返回集合中给定索引开始后面的部分： array_slice()\r\n```PHP\r\n>>> collect([1, 2, 3, 4, 5, 6, 7])->slice(3)->all()\r\n=> [\r\n     3 => 4,\r\n     4 => 5,\r\n     5 => 6,\r\n     6 => 7,\r\n   ]\r\n>>> collect([1, 2, 3, 4, 5, 6, 7])->slice(2,2)->all()\r\n=> [\r\n     2 => 3,\r\n     3 => 4,\r\n   ]\r\n```\r\n\r\n#### split()\r\n#### chunk()\r\n> chunk($size) 集合分割成多个指定大小的较小集合\r\n#### sort()\r\n#### sortDesc()\r\n#### sortBy()\r\n#### sortByDesc()\r\n#### sortKeys()\r\n#### sortKeysDesc()\r\n#### splice()\r\n#### take()\r\n#### takeUntil()\r\n#### takeWhile()\r\n#### transform()\r\n> transform(callable $callback) 方法会遍历整个集合，并对集合中的每项都会调用其回调函数,和map原理一致，但是该方法会改变原有集合\r\n```PHP\r\n// map不会改变原集合的值\r\n>>> $a = collect([1,2,3,4,5]);\r\n>>> $a->map(function($item,$key){return $item*2;})\r\n>>> $a->all();\r\n=> [1,2,3,4,5,]\r\n// transform改变原集合\r\n>>> $a->transform(function($item,$key){return $item*2;})\r\n>>> $a->all();\r\n=> [2,4,6,8,10,]\r\n>>>\r\n```\r\n#### values()\r\n#### zip()\r\n#### pad()\r\n#### getIterator()\r\n#### count()\r\n#### add()\r\n#### toBase()\r\n> 基于当前集合返回一个新的集合\r\n#### offsetExists()\r\n#### offsetGet()\r\n#### offsetSet()\r\n#### offsetUnset()\r\n\r\n\r\n\r\n\r\n\r\n  [1]: https://github.com/xiaoxie110/laravel/blob/master/vendor/laravel/framework/src/Illuminate/Support/Collection.php",
      "data": {
        "title": "Laravel学习-Collect",
        "date": "2020-06-06 18:13:32",
        "tags": [
          "laravel",
          "collect"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "laravel-collect"
    },
    {
      "content": "\n> 欢迎来到我的小站呀，很高兴遇见你！🤝\n\n## 🏠 关于本站\n\n## 👨‍💻 博主是谁\n\n## ⛹ 兴趣爱好\n\n## 📬 联系我呀\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n<!-- more -->\n\n[Github](https://github.com/getgridea/gridea)  \n[Gridea 主页](https://gridea.dev/)  \n[示例网站](http://fehey.com/)\n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **Windows**，**MacOS** 或 **Linux** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \n\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \n\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前 🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": true,
        "feature": "/post-images/hello-gridea.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... ",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "name": "cache",
      "slug": "dWgkYYvpg",
      "used": true
    },
    {
      "name": "laravel",
      "slug": "-83BydD-k",
      "used": true
    },
    {
      "name": "collect",
      "slug": "4vrsv0q_Rt",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "nqZh1LZMw",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}