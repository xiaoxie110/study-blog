{
  "posts": [
    {
      "content": "> 集合（Collection）Illuminate\\Support\\Collection 类了提供一个便捷的操作数组的封装。[Collection.php源码解读][1]\r\n\r\n[TOC]\r\n\r\n### 创建一个新的集合\r\n \r\n```PHP\r\n//collect 辅助函数会为指定的数组返回一个新的 Illuminate\\Support\\Collection 实例\r\n//构造函数\r\npublic function __construct($items = [])\r\n{\r\n    //可以直接将多种类型转换为数组 Laravel Eloquent ORM 也以集合的形式返回数据\r\n    $this->items = $this->getArrayableItems($items);\r\n}\r\n// 创建一个新的集合\r\n$newCollection = collect([1, 2, 3, 4, 5]);\r\n```\r\n\r\n### 静态函数 times()\r\n```PHP\r\n静态 times 方法通过调用给定次数的回调函数来创建新集合：\r\n\r\npublic static function times($number, callable $callback = null)\r\n{\r\n    if ($number < 1) {\r\n        return new static;\r\n    }\r\n    if (is_null($callback)) {// 回调函数为空，直接返回range()\r\n        return new static(range(1, $number));\r\n    }\r\n    return (new static(range(1, $number)))->map($callback);//给定次数调用回调函数\r\n}\r\n// 基本用法\r\n> Illuminate\\Support\\Collection::times(10, function ($number) {\r\n    return $number * 9;\r\n})all();\r\n=> [9, 18, 27, 36, 45, 54, 63, 72, 81, 90]\r\n\r\n// 回调函数为空，直接返回range()\r\n> Illuminate\\Support\\Collection::times(2)->all();\r\n=> [1,2,]\r\n```\r\n### 懶集合 LazyCollection\r\n>LazyCollection 类利用了PHP的生成器来在保持低内存使用率的同时使用非常大的数据集 关键字（yield）。\r\n```PHP\r\nuse App\\LogEntry;\r\nuse Illuminate\\Support\\LazyCollection;\r\n\r\nLazyCollection::make(function () {\r\n    $handle = fopen('log.txt', 'r');\r\n    while (($line = fgets($handle)) !== false) {\r\n        yield $line;\r\n    }\r\n})->chunk(4)->map(function ($lines) {\r\n    return LogEntry::fromLines($lines);\r\n})->each(function (LogEntry $logEntry) {\r\n    // Process the log entry...\r\n});\r\n```\r\n\r\n### 基本数据处理\r\n#### avg()\r\n> avg($callback = null) 集合平均值，支持回调函数\r\n```PHP\r\n// 一般用法\r\n>>> collect([1, 1, 2, 4])->avg();\r\n=> 2\r\n\r\n// 指定键\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->avg('foo')\r\n=> 20\r\n\r\n// 回调函数\r\n>>> collect([['foo' => 10], ['foo' => 20], ['foo' => 40]])->avg(function($val){return $val['foo']/10;});\r\n=> 2.3333333333333\r\n```\r\n\r\n#### median()\r\n> median($key = null) 集合中位数，可以指定键\r\n```PHP\r\n// 一般用法\r\n>>> collect([1, 1, 2, 4])->median();\r\n=> 1.5\r\n\r\n// 指定键中位数\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 40]])->median('foo');\r\n=> 15\r\n```\r\n\r\n#### mode()\r\n> mode($key = null) 集合众数 指定键的众数[一组数据中出现次数最多的数值，有可能是多个]\r\n```PHP\r\n// 一般用法\r\n>>> collect([1, 1, 2, 4])->mode();\r\n=> [1]\r\n\r\n// 指定键众数\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 20], ['foo' => 40]])->mode('foo');\r\n=> [10,20]\r\n```\r\n\r\n#### collapse()\r\n> 一个多个一维数组集合组装为单个一维数组集合\r\n```PHP\r\n// 多个一维数组的值 array_merege\r\n>>> collect([[1, 2, 3], [4, 5, 6], [7, 8, 9]])->collapse()->all()\r\n=> [1,2,3,4,5,6,7,8,9]\r\n// 不适用多维数组\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 20], ['foo' => 20], ['foo' => 40]])->collapse()->all()\r\n=> [\"foo\" => 40]\r\n>>>\r\n```\r\n\r\n#### contains()\r\n>contains($key, $operator = null, $value = null) 方法检查集合有否包含指定的元素\r\ncontains 方法用 “松散” 比较检查元素值，用 containsStrict 方法使用 “严格” 比较过滤。\r\n```PHP\r\n// 单个数值或者回調函數判断\r\n>>> collect([1,2,3,4])->contains(1)\r\n=> true\r\n>>> collect([['foo' => 10],['foo' => 20]])->contains(function($val){ return $val['foo'] > 20 ;});\r\n=> true\r\n\r\n// 数组，键值对\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->contains(['foo' => 10])\r\n=> true\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->contains('foo',10)\r\n=> true\r\n// 支持多種比較查詢 == <> > < !== 等等\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->contains('foo', '>', 10)\r\n=> true\r\n```\r\n\r\n#### crossJoin()\r\n> crossJoin(...$lists)  方法交叉连接指定数组或集合的值，返回所有可能排列的笛卡尔积\r\n\r\n```PHP\r\n// 数组循环迭代，每次每个集合中取一个 类似于 An1*M \r\n>>> collect([1,2])->crossJoin([3,4])->all()\r\n=> [\r\n     [1,3],\r\n     [1,4],\r\n     [2,3],\r\n     [2,4],\r\n   ]\r\n>>>\r\n\r\n```\r\n\r\n#### diff()\r\n>数组中array_diff()方法，本函数只检查了多维数组中的一维\r\n```PHP\r\n>>> collect([1,2])->diff([1,2,3,4])->all()\r\n=> []\r\n>>> collect([1,2,5])->diff([1,2,3,4])->all()\r\n=> [2 => 5]\r\n```\r\n#### diffUsing()\r\n#### diffAssoc()\r\n#### diffAssocUsing()\r\n#### diffKeys()\r\n#### diffKeysUsing()\r\n#### duplicates()\r\n>duplicates($callback = null, $strict = false) 从集合中检索并返回重复的值\r\n```PHP\r\n// 一般用法\r\n>>> collect(['a', 'b', 'a', 'c', 'b'])->duplicates()->all()\r\n=> [2 => \"a\", 4 => \"b\"]\r\n// 如果集合包含数组或对象，则可以需要检查重复值的属性的键\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->duplicates('foo')->all();\r\n=> [1 => 10]\r\n```\r\n#### duplicatesStrict()\r\n#### except()\r\n> except($keys) 方法返回集合中除了指定键之外的所有集合项：\r\n```PHP\r\n// 参数可传单个字段，也可以传枚举类型的数组\r\n>>> collect(['foo' => 10, 'foo2' => 10, 'foo' => 40])->except('foo')->all();\r\n=> [\"foo2\" => 10]\r\n>>> collect(['foo' => 10, 'foo2' => 10, 'foo3' => 40])->except(['foo','foo2'])->all();\r\n=> [\"foo3\" => 10]\r\n```\r\n\r\n#### filter()\r\n> 用给定的回调函数过滤集合，只保留那些通过指定条件测试的集合项;如果没有提供回调函数，集合中所有返回 false 的元素都会被移除\r\n```PHP\r\n// 指定回调函数，过滤集合\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->filter(function($val){ return $val['foo'] > 20;})->all();\r\n=> [\r\n     2 => [\r\n       \"foo\" => 40,\r\n     ],\r\n   ]\r\n// 没有回调函数，直接过滤false array_filter()\r\n>>> collect([1, 2, 3, null, false, '', 0, []])->filter()->all()\r\n=> [1, 2, 3]\r\n```\r\n\r\n#### first()\r\n> first(callable $callback = null, $default = null) 从集合中返回符合条件的第一个值，支持回调函数；可设置默认值$default\r\n```PHP\r\n>>> collect()->first();\r\n=> null\r\n>>> collect([1, 2, 3, 4])->first();\r\n=> 1\r\n>>> collect([1, 2, 3, 4])->first(function($val){ return $val > 30;});\r\n=> null\r\n>>> collect([1, 2, 3, 4])->first(function($val){ return $val > 3;});\r\n=> 4\r\n>>> collect([1, 2, 3, 4])->first(function($val){ return $val > 5;}, 5);\r\n=> 5\r\n```\r\n\r\n#### flatten()\r\n> flatten($depth = INF) flatten($depth = INF) 将多维集合转换为一维集合，其中 $depth 为转换深度\r\n```PHP\r\n>>> collect([['foo' => 10], ['foo' => 10], ['foo' => 40]])->flatten()->all();\r\n=> [10,10,40]\r\n>>> collect([1=>'a', 2=>['b'=>['c' => 'd']]])->flatten(2)->all()\r\n=> [\"a\",\"d\",]\r\n```\r\n\r\n#### flip()\r\n#### forget()\r\n> forget($keys) 通过指定的键来移除集合中对应的内容\r\n```PHP\r\n>>> collect(['foo' => 10, 'foo2' => 10, 'foo3' => 40])->forget(['foo','foo2'])->all();\r\n=> [\"foo3\" => 40]\r\n```\r\n#### get()\r\n> get($key, $default = null) 方法返回指定键的集合项，如果该键在集合中不存在，则返回 null；可传递默认参数default，该默认参数可为回调函数\r\n```PHP\r\n>>> collect(['a' => 1])->get('a')\r\n=> 1\r\n>>> collect(['a' => 1])->get('b')\r\n=> null\r\n>>> collect(['a' => 1])->get('b', 11)\r\n=> 11\r\n>>> collect(['a' => 1])->get('b', function(){return 111;})\r\n=> 111\r\n>>>\r\n```\r\n\r\n#### groupBy()\r\n#### keyBy()\r\n> 方法以指定的键作为新集合的键。如果多个集合项具有相同的键，则只有最后一个集合项会显示在新集合中;支持对调函数 \r\n```PHP\r\n// 一般使用，直接传递某个键\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->keyBy('a')->all()\r\n=> [\r\n     1 => [\"a\" => 1,\"b\" => 2,],\r\n     3 => [\"a\" => 3,\"b\" => 4,],\r\n   ]\r\n// 回调函数返回的值会作为该集合的键   \r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->keyBy(function($item){return $item['a']+10;})->all()\r\n=> [\r\n     11 => [\"a\" => 1,\"b\" => 2,],\r\n     13 => [\"a\" => 3,\"b\" => 4,],\r\n   ]\r\n```\r\n\r\n#### has()\r\n> has($key) 判断集合中是否存在指定键,支持传入多个键 array_key_exists底层方法\r\n```PHP\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->has('a')\r\n=> true\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->has(['a','b'])\r\n=> true\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->has(['a','b','d'])\r\n=> false\r\n```\r\n\r\n#### implode\r\n> implode($value, $glue = null) 用于合并集合项\r\n```PHP\r\n// 集合中包含简单的字符串或数值\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->implode('*')\r\n=> \"1*2*3\"\r\n// 集合包含数组或对象\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->implode('a', '**')\r\n=> \"1**3\"\r\n```\r\n\r\n#### intersect()\r\n#### intersectByKeys()\r\n#### isEmpty()\r\n#### join()\r\n>join($glue, $finalGlue = '') 将集合中的值用字符串连接\r\n```PHP\r\n>>> collect(['a', 'b', 'c'])->join(', ');\r\n=> 'a, b, c'\r\n>>> collect(['a', 'b', 'c'])->join(', ', ', and ');\r\n=> 'a, b, and c'\r\n>>> collect(['a', 'b'])->join(', ', ' and ');\r\n=> 'a and b'\r\n>>> collect(['a'])->join(', ', ' and '); \r\n=> 'a'\r\n>>> collect([])->join(', ', ' and '); \r\n=> ''\r\n```\r\n\r\n#### keys()\r\n#### last()\r\n>last() 返回集合中通过指定条件测试的最后一个元素\r\n```PHP\r\n// 一般调用，直接返回最后有一个元素\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->last();\r\n=> 3\r\n// 回调函数，返回符合条件的最后一个元素\r\n>>> collect([ 'a'=>1,'b'=>2, 'c'=>3])->last(function($val){return $val<2;});\r\n=> 1\r\n```\r\n\r\n#### pluck()\r\n> pluck($value, $key = null) 方法可以获取集合中指定键对应的所有值\r\n```PHP\r\n// 指定键对应的所有值\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->pluck('a')->all();\r\n=> [1,3]\r\n// 指定生成集合的键\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->pluck('a', 'b')->all();\r\n=> [2 => 1, 4 => 3]\r\n// 如果存在重复的键，则最后一个匹配元素将被插入到弹出的集合中\r\n>>> collect([['a'=>1,'b'=>2],['a'=>3,'b'=>2]])->pluck('a', 'b')->all();\r\n=> [2 => 3]\r\n```\r\n\r\n#### map()\r\n> map(callable $callback) 遍历集合并将每一个值传入给定的回调函数, 生成被修改过集合项的新集合\r\n```PHP\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>2]])->map(function($item, $key){ return $item['a'] * 2;})->all();\r\n=> [2,6]\r\n```\r\n\r\n#### mapToDictionary()\r\n#### mapWithKeys() \r\n>遍历集合并将每个值传入给定的回调函数。将返回一个包含单个键 / 值对的关联数组\r\n```PHP\r\n>>> collect([[ 'a'=>1,'b'=>2],['a'=>3,'b'=>4]])->mapWithKeys(function($item){return [$item['a'] => $item['b']];})->all()\r\n=> [\r\n     1 => 2,\r\n     3 => 4,\r\n   ]\r\n```\r\n\r\n#### merge() \r\n>方法将合并指定的数组或集合到原集合，如果给定的集合项的字符串键与原集合中的字符串键相匹配，则指定集合项的值将覆盖原集合的值 array_merge\r\n```PHP\r\n// 一般使用\r\n>>> collect([ 'a'=>1,'b'=>2])->merge(['c' => 5])->all();\r\n=> [\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n     \"c\" => 5,\r\n   ]\r\n// 有覆盖\r\n>>> collect([ 'a'=>1,'b'=>2])->merge(['a' => 5])->all();\r\n=> [\r\n     \"a\" => 5,\r\n     \"b\" => 2,\r\n   ]\r\n```\r\n#### mergeRecursive()\r\n> 以递归的形式合并给定的数组或集合到原集合中 array_merge_recursive\r\n```PHP\r\n// 同一个键值的合并\r\n>>> collect(['a'=>1,'b'=>2])->mergeRecursive(['a' => 5])->all();\r\n=> [\"a\" => [1,5,\"b\" => 2]\r\n>>> collect([ 'a'=>['c'=>1],'b'=>2])->mergeRecursive(['a' => 5])->all();\r\n=> [\"a\" => [\"c\" => 1,0 => 5,],\"b\" => 2,]\r\n```\r\n\r\n#### combine()\r\n> 将一个集合的值作为键，与另一个数组或集合的值进行结合 array_combine\r\n```PHP\r\n// 一般使用\r\n>>> collect(['a', 'b'])->combine([1,2])->all()\r\n=> [\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n   ]\r\n// 只能传递相等数量的集合\r\n>>> collect(['a', 'b'])->combine([1,2,3])->all()\r\nPHP Warning:  array_combine(): Both parameters should have an equal number of elements in D:/dev/study/laravel/vendor/laravel/framework/src/Illuminate/Support/Collection.php on line 777\r\n=> [\r\n     false,\r\n   ]\r\n```\r\n\r\n#### union()\r\n> 方法将给定数组添加到集合中。如果给定的数组含有与原集合一样的键，则首选原始集合的值,这点和merge相反\r\n```PHP\r\n>>> collect(['a'=>1, 'b'=>2])->union(['a'=>3,'d'=>4])->all()\r\n=> [\r\n     \"a\" => 1,\r\n     \"b\" => 2,\r\n     \"d\" => 4,\r\n   ]\r\n>>> collect(['a'=>1, 'b'=>2])->merge(['a'=>3,'d'=>4])->all()\r\n=> [\r\n     \"a\" => 3,\r\n     \"b\" => 2,\r\n     \"d\" => 4,\r\n   ]\r\n\r\n```\r\n\r\n#### nth()\r\n\r\n#### only()\r\n> 返回集合中所有指定键的集合项\r\n```PHP\r\n>>> collect(['a'=>1, 'b'=>2])->only('a')->all()\r\n=> [\r\n     \"a\" => 1,\r\n   ]\r\n```\r\n\r\n#### pop()\r\n#### prepend()\r\n\r\n\r\n\r\n\r\n\r\n\r\n  [1]: https://github.com/xiaoxie110/laravel/blob/master/vendor/laravel/framework/src/Illuminate/Support/Collection.php",
      "data": {
        "title": "Laravel学习-Collect",
        "date": "2020-06-06 18:13:32",
        "tags": [
          "laravel",
          "collect"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "laravel-collect"
    },
    {
      "content": "\n> 欢迎来到我的小站呀，很高兴遇见你！🤝\n\n## 🏠 关于本站\n\n## 👨‍💻 博主是谁\n\n## ⛹ 兴趣爱好\n\n## 📬 联系我呀\n",
      "data": {
        "title": "关于",
        "date": "2019-01-25 19:09:48",
        "tags": [],
        "published": true,
        "hideInList": true,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... \n\n<!-- more -->\n\n[Github](https://github.com/getgridea/gridea)  \n[Gridea 主页](https://gridea.dev/)  \n[示例网站](http://fehey.com/)\n\n## 特性👇\n📝  你可以使用最酷的 **Markdown** 语法，进行快速创作  \n\n🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片  \n\n🏷️  你可以对文章进行标签分组  \n\n📋  你可以自定义菜单，甚至可以创建外部链接菜单  \n\n💻  你可以在 **Windows**，**MacOS** 或 **Linux** 设备上使用此客户端  \n\n🌎  你可以使用 **𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌** 或 **Coding Pages** 向世界展示，未来将支持更多平台  \n\n💬  你可以进行简单的配置，接入 [Gitalk](https://github.com/gitalk/gitalk) 或 [DisqusJS](https://github.com/SukkaW/DisqusJS) 评论系统  \n\n🇬🇧  你可以使用**中文简体**或**英语**  \n\n🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力  \n\n🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步  \n\n🌱 当然 **Gridea** 还很年轻，有很多不足，但请相信，它会不停向前 🏃\n\n未来，它一定会成为你离不开的伙伴\n\n尽情发挥你的才华吧！\n\n😘 Enjoy~\n",
      "data": {
        "title": "Hello Gridea",
        "date": "2018-12-12 00:00:00",
        "tags": [
          "Gridea"
        ],
        "published": true,
        "hideInList": true,
        "feature": "/post-images/hello-gridea.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "👏  欢迎使用 **Gridea** ！  \n✍️  **Gridea** 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... ",
      "fileName": "hello-gridea"
    }
  ],
  "tags": [
    {
      "name": "laravel",
      "slug": "-83BydD-k",
      "used": true
    },
    {
      "name": "collect",
      "slug": "4vrsv0q_Rt",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "nqZh1LZMw",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}